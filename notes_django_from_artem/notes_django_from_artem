notes_django_from_artem

$ mkdir django_from_artem
$ cd django_from_artem/

$ python3 -m venv my_env
$ source my_env/bin/activate
$ pip install -U pip setuptools django

$ django-admin startproject mysite
$ cd mysite/

$ code .

$ python manage.py migrate
$ python manage.py runserver

$ python manage.py startapp blog

models.py
        from django.db import models
        from django.utils import timezone


        class Post(models.Model):
            title = models.CharField(max_length=250)   
            slug = models.SlugField(max_length=250, unique_for_date='publish')    
            body = models.TextField()       
            publish = models.DateTimeField(default=timezone.now)    
            created = models.DateTimeField(auto_now_add=True)    
            updated = models.DateTimeField(auto_now=True) 

            class Meta:
                ordering = ['-publish']

            indexes = [
                    models.Index(fields=['-publish']),
                ]

            def __str__(self):
                return self.title
                

settings.py
        INSTALLED_APPS = [
            'django.contrib.admin',
            'django.contrib.auth',
            'django.contrib.contenttypes',
            'django.contrib.sessions',
            'django.contrib.messages',
            'django.contrib.staticfiles',
            'blog.apps.BlogConfig',
        ]



models.py
        from django.db import models
        from django.utils import timezone
        from django.contrib.auth.models import User


        class Post(models.Model):

            class Status(models.TextChoices):
                DRAFT = 'DF', 'Draft'
                PUBLISHED = 'PB', 'Published'

            title = models.CharField(max_length=250)   
            slug = models.SlugField(max_length=250, unique_for_date='publish')
            author = models.ForeignKey(User,
                                       on_delete=models.CASCADE,
                                       related_name='blog_posts')    
            body = models.TextField()       
            publish = models.DateTimeField(default=timezone.now)    
            created = models.DateTimeField(auto_now_add=True)    
            updated = models.DateTimeField(auto_now=True) 
            status = models.CharField(max_length=2,
                                      choices=Status.choices,
                                      default=Status.DRAFT)

            class Meta:
                ordering = ['-publish']

            indexes = [
                    models.Index(fields=['-publish']),
                ]

            def __str__(self):
                return self.title

$ python manage.py makemigrations blog
$ python manage.py migrate
$ python manage.py createsuperuser

$ python manage.py runserver



admin.py
        from django.contrib import admin
        from .models import Post


        admin.site.register(Post)

проверить админку

admin.py
        from django.contrib import admin
        from .models import Post


        @admin.register(Post)
        class PostAdmin(admin.ModelAdmin):
            list_display = ['title', 'slug', 'author', 'publish', 'status', 'created']
            # правая панель позволяет фильтровать результаты по полям, включенным в атрибут list_filter
            list_filter = ['status', 'created', 'publish', 'author']

            # строка поиска
            search_fields = ['title', 'body']

            # slug заполняется автоматически (при заполнении поста)
            prepopulated_fields = {'slug': ('title',)}

            # поле author отображается поисковым виджетом (при заполнении поста)
            raw_id_fields = ['author']

            # навигационные ссылки для навигации по иерархии дат
            date_hierarchy = 'publish'

            # по умолчанию упорядочены по столбцам STATUS (Статус) и PUBLISH (Опубликован)
            ordering = ['status', 'publish']


проверить админку, создать пост


models.py
        from django.db import models
        from django.utils import timezone
        from django.contrib.auth.models import User


        # конкретно-прикладной менеджер для модели Post, возвращает опубликованные посты 
        class PublishedManager(models.Manager):
            def get_queryset(self):
                return super().get_queryset()\
                .filter(status=Post.Status.PUBLISHED)


        class Post(models.Model):

            class Status(models.TextChoices):
                DRAFT = 'DF', 'Draft'
                PUBLISHED = 'PB', 'Published'

            title = models.CharField(max_length=250)   
            slug = models.SlugField(max_length=250, unique_for_date='publish')
            author = models.ForeignKey(User,
                                       on_delete=models.CASCADE,
                                       related_name='blog_posts')    
            body = models.TextField()       
            publish = models.DateTimeField(default=timezone.now)    
            created = models.DateTimeField(auto_now_add=True)    
            updated = models.DateTimeField(auto_now=True) 
            status = models.CharField(max_length=2,
                                      choices=Status.choices,
                                      default=Status.DRAFT)
            
            objects = models.Manager() # менеджер, применяемый по умолчанию
            published = PublishedManager() # конкретно-прикладной менеджер

            class Meta:
                ordering = ['-publish']

            indexes = [
                    models.Index(fields=['-publish']),
                ]

            def __str__(self):
                return self.title


views.py
        from django.shortcuts import render
        from .models import Post
        from django.http import Http404


        # представления списка опубликованных постов на странице
        def post_list(request):
            posts = Post.published.all()    
            
            return render(request,
                          'blog/post/list.html',
                          {'posts': posts})


        # представление одиночного поста (s1). Открыть пост по id
        def post_detail(request, id):
            try:
                post = Post.published.get(id=id)

            # исключение Http404, чтобы вернуть ошибку HTTP с кодом 
            # состояния, равным 404, если возникает исключение DoesNotExist, 
            # то есть модель не существует, поскольку результат не найден.
            except Post.DoesNotExist:
                raise Http404("No post found.")
           
            return render(request,
                          'blog/post/detail.html',
                          {'post': post})


        Применение функции сокращенного доступа get_object_or_404()
        
views.py
        from django.shortcuts import render, get_object_or_404
        from .models import Post
        from django.http import Http404


        # представления списка опубликованных постов на странице
        def post_list(request):
            posts = Post.published.all()    
            
            return render(request,
                          'blog/post/list.html',
                          {'posts': posts})


        # представление одиночного поста (s1). Открыть пост по id
        def post_detail(request, id):
            # try:
            #     post = Post.published.get(id=id)

            # # исключение Http404, чтобы вернуть ошибку HTTP с кодом 
            # # состояния, равным 404, если возникает исключение DoesNotExist, 
            # # то есть модель не существует, поскольку результат не найден.
            # except Post.DoesNotExist:
            #     raise Http404("No post found.")
            
            # функцию сокращенного доступа для вызова метода get() и вызова исключения Http404 когда объект не найден
            post = get_object_or_404(Post,
                                     id=id,
                                     status=Post.Status.PUBLISHED)
           
            return render(request,
                          'blog/post/detail.html',
                          {'post': post})



Добавление шаблонов URL-адресов представлений
blog создайте файл urls.py

urls.py
        from django.urls import path
        from . import views


        # определяется именное пространство
        app_name = 'blog'


        urlpatterns = [
            # все посты на странице
            path('', views.post_list, name='post_list'),
            # детальное представление поста по id
            path('<int:id>/', views.post_detail, name='post_detail'),
        ]


mysite/urls.py
        """
        URL configuration for mysite project.

        The `urlpatterns` list routes URLs to views. For more information please see:
            https://docs.djangoproject.com/en/4.2/topics/http/urls/
        Examples:
        Function views
            1. Add an import:  from my_app import views
            2. Add a URL to urlpatterns:  path('', views.home, name='home')
        Class-based views
            1. Add an import:  from other_app.views import Home
            2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
        Including another URLconf
            1. Import the include() function: from django.urls import include, path
            2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
        """
        from django.contrib import admin
        from django.urls import path, include

        urlpatterns = [
            path('admin/', admin.site.urls),
            path('blog/', include('blog.urls', namespace='blog')),
        ]


Создание базового шаблона
blog/templates/blog/base.html
        {% load static %}
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>
                {% block title %}
                {% endblock %}
            </title>

            <link href="{% static "css/blog.css" %}"  rel="stylesheet">

        </head>
        <body>
            <div id="content">
                {% block content %}
                {% endblock %}
            </div>

            <div id="sidebar">
                <h2>📽 Киноблог Старинского</h2>
                <p>Меню.</p>
            </div>
            
        </body>
        </html>


create
mysite/blog/static/css/blog.css

        body { 
            margin:0;
            padding:0;
            font-family:helvetica, sans-serif;     
        }

        a { 
            color:#066696;
            text-decoration:none; 
        }

        h1 { 
            font-weight:normal;
            border-bottom:1px solid #bbb;
            padding:0 0 10px 0;
        }

        h2 {
            font-weight:normal;
            margin:30px 0 0;
        }

        #content { 
            float:left;
            width:60%;
            padding:0 0 0 30px; 
            background-color: #86f7b1;
        }

        #sidebar { 
            float:right;
            width:30%;
            padding:10px;
            background:#9ef0ec; 
            height:100%;
        }

        p.date { 
            color:#1b9199;
            font-family: georgia, serif;
            font-size: 12px;
            font-style: italic; 
        }

        /* pagination */
        .pagination { 
            margin:40px 0; 
            font-weight:bold;
        }

        /* forms */
        label { 
            float:left;
            clear:both;
            color:#333;
            margin-bottom:4px; 
        }
        input, textarea { 
            clear:both;
            float:left;
            margin:0 0 10px;
            background:#ededed;
            border:0;
            padding:6px 10px;
            font-size:12px;
        }
        input[type=submit] {
            font-weight:bold;
            background:#00abff;
            color:#fff;
            padding:10px 20px;
            font-size:14px;
            text-transform:uppercase; 
        }
        .errorlist { 
            color:#cc0033;
            float:left;
            clear:both;
            padding-left:10px; 
        }

        /* comments */
        .comment {
            padding:10px;
        }
        .comment:nth-child(even) {
            background:#efefef;
        }
        .comment .info {
            font-weight:bold;
            font-size:12px;
            color:#666;
        }




blog/templates/blog/post/list.html
        {% extends "blog/base.html" %}

        {% block title %}
            My blog
        {% endblock %}

        {% block content %}
            <h1>My blog</h1>
            {% for post in posts %}
                <h2>            
                    <a href="{% url 'blog:post_detail' post.id %}">
                        {{ post.title }}
                    </a>            
                </h2>

                <p class="date">
                    Published {{ post.publish }} by {{ post.author }}
                </p>

                {{ post.body|truncatewords:30|linebreaks }}
            {% endfor %}
        {% endblock %}

        <!-- 
            два шаблонных фильтра: 
            truncatewords усекает значение до указанного числа слов, а 
            linebreaks конвертирует результат в разрывы строк в формате HTML. 
        -->


$ python manage.py runserver


blog/templates/blog/post/detail.html
        {% extends "blog/base.html" %}

        {% block title %}
            {{ post.title }}
        {% endblock %}

        {% block content %}
            <h1>{{ post.title }}</h1>

            <p class="date">
                Publidhed {{ post.publish }} by {{ post.author }}
            </p>
            {{ post.body|linebreaks }}  
        {% endblock %}



Использование канонических URL-адресов для моделей (reverse() и
        get_absolute_url())

!!! Что это такое Канонический адрес

models.py
        from django.urls import reverse

        ...
        ...
        def __str__(self):
                return self.title
            
        # Использование канонических URL-адресов
        def get_absolute_url(self):
                return reverse('blog:post_detail',
                                args=[self.id])


list.html

        ...
        ...
         {% for post in posts %}
                <h2>            
                    <!-- <a href="{% url 'blog:post_detail' post.id %}"> -->
                        
                    <!-- Использование канонических URL -->
                    <a href="{{ post.get_absolute_url }}">
                        {{ post.title }}
                    </a>            
                </h2>

        ...
        ...



$ ./manage.py runserver
Теперь Django формирует URL поста, используя метод get_absolute_url() модели Post.


СОЗДАНИЕ ДРУЖЕСТВЕННЫХ ДЛЯ ПОИСКОВОЙ ОПТИМИЗАЦИИ URL-АДРЕСОВ ПОСТОВ
        Канонический URL-адрес представления детальной информации о посте
        блога в настоящее время выглядит как 
        /blog/1/. 
        Мы изменим шаблон URL-адреса, чтобы формировать дружественные для
         поисковой оптимизации
        URL-адреса постов. В целях формирования URL-адресов одиночных постов
        мы будем использовать дату публикации publish и значения slug. Присоеди-
        нив даты, мы приведем URL-адрес детальной информации о посте к следую-
        щему виду: 
        /blog/2022/1/1/who-was-django-reinhardt/.
        
        Мы предотвратим хранение в модели Post дублирующихся записей,
         определив, что слаги являются уникальными для
         даты публикации поста.




$ python manage.py makemigrations blog
$ python manage.py migrate
создадим миграцию только для того, чтобы привести миграции в соответствие
с текущим состоянием модели.
Мне не нужно, т.к параметрт 
        slug = models.SlugField(max_length=250,
                unique_for_date='publish')   - написал сразу
        
        рез-ат миграции -  No migrations to apply.
        (+ Обратите
внимание, что параметр unique_for_date не соблюдается на уровне базы дан-
ных, поэтому миграция базы данных не требуется.)


        Видоизменение шаблонов URL-адресов

urls.py
        urlpatterns = [
            # все посты на странице
            path('', views.post_list, name='post_list'),

            # # детальное представление поста по id
            # path('<int:id>/', views.post_detail, name='post_detail'),

            # исполью дату и слаг для URL-адреса 
            path('<int:year>/<int:month>/<int:day>/<slug:post>/',
                 views.post_detail,
                 name='post_detail'),
        ]


        Видоизменение представлений

views.py
        # # Детальное представление одиночного поста . Открыть пост по id
        # def post_detail(request, id):
        #     # try:
        #     #     post = Post.published.get(id=id)


        #     # # исключение Http404, чтобы вернуть ошибку HTTP с кодом 
        #     # # состояния, равным 404, если возникает исключение DoesNotExist, 
        #     # # то есть модель не существует, поскольку результат не найден.
        #     # except Post.DoesNotExist:
        #     #     raise Http404("No post found.")        
            
        #     # функцию сокращенного доступа для вызова метода get() 
        #     # и вызова исключения Http404 когда объект не найден
        #     post = get_object_or_404(Post,
        #                              id=id,
        #                              status=Post.Status.PUBLISHED)
            
           

        # Детальное представление поста. Исполью дату и слаг для URL-адреса 
        def post_detail(request, year, month, day, post):
            post = get_object_or_404(Post,
                                     status=Post.Status.PUBLISHED,
                                     slug=post,
                                     publish__year=year,
                                     publish__month=month,
                                     publish__day=day)



        Видоизменение канонического URL-адреса постов
models.py
        ...
        ...
        # # Использование канонических URL-адресов
            # def get_absolute_url(self):
            #     return reverse('blog:post_detail',
            #                    args=[self.id])


            # исполью дату и слаг для URL-адреса 
            def get_absolute_url(self):
                return reverse('blog:post_detail',
                               args=[self.publish.year,
                                     self.publish.month,
                                     self.publish.day,
                                     self.slug])


$ python manage.py runserver
теперь ссылки на пост
        http://127.0.0.1:8000/blog/2023/5/11/novaya-paradigma-realnosti-krov-stynet-v-zhilah/
        
        http://127.0.0.1:8000/blog/2023/5/10/socialno-orientirovannyj/

 новый метод (не отслеживает время публикации) отслеживает заоловок и дату
 и не позволяет создать два поста с одинаковыми заголовками в одну дату!
 
 

ДОБАВЛЕНИЕ ПОСТРАНИЧНОЙ РАЗБИВКИ
Добавление постраничной разбивки в представление списка постов

views.py
        from django.core.paginator import Paginator


        # представления списка опубликованных постов на странице
        # def post_list(request):
        #     posts = Post.published.all()    
            
        #     return render(request,
        #                   'blog/post/list.html',
        #                   {'posts': posts})


        # представления списка опубликованных постов на странице
        # c постраничной разбивкой
        def post_list(request):
            # Постраничная разбивка с 3 постами на страницу
            post_list = Post.published.all()
            paginator = Paginator(post_list, 3)
            # содержит запрошенный номер страницы.
            # Если параметра page нет в GET-параметрах запроса, 
            # то мы используем стандартное значение 1, 
            # чтобы загрузить первую страницу результатов.
            page_number = request.GET.get('page', 1)
            posts = paginator.page(page_number)
            
            return render(request,
                          'blog/post/list.html',
                          {'posts': posts})


Создание шаблона постраничной разбивки
создайте новый файл templates/pagination.html

pagination.html
        <div class="pagination">
            <span class="step-links">
                {% if page.has_previous %}
                    <a href="?page={{ page.previous_page_number }}">Предыдущая</a>
                {% endif %}

                <span class="current">
                    Страница {{ page.number }} из {{ page.paginator.num_pages }}.
                </span>

                {% if page.has_next %}
                    <a href="?page={{ page.next_page_number }}">Следующая</a>
                {% endif %}
            </span>
        </div>



list.html
        ...
        ...
         {{ post.body|truncatewords:30|linebreaks }}
            {% endfor %}
            
            <!-- блок с пагинацией -->
            {% include "pagination.html" with page=posts %}
        {% endblock %}


$ python manage.py runserver
создатьмин 4 поста, что бы проверить пагинацию


        Обработка ошибок постраничной разбивки

        если в url набрать номер несуществующей страницы
        http://127.0.0.1:8000/blog/?page=4
        то будет ошибка
        выполним соответствующую обработку ошибок для таких случаев.

!!! кто, какой url ловит этот параметр page=4?

views.py
        from django.core.paginator import Paginator, EmptyPage

        # представления списка опубликованных постов на странице
        # c постраничной разбивкой
        def post_list(request):
            # Постраничная разбивка с 3 постами на страницу
            post_list = Post.published.all()
            paginator = Paginator(post_list, 3)
            # содержит запрошенный номер страницы.
            # Если параметра page нет в GET-параметрах запроса, 
            # то мы используем стандартное значение 1, 
            # чтобы загрузить первую страницу результатов.
            page_number = request.GET.get('page', 1)

            # обработка ошибки с несуществующей ошибкой
            try:
                posts = paginator.page(page_number)
            
            # Если page_number находится вне диапазона, то
            # выдать последнюю страницу
            except EmptyPage:
                posts = paginator.page(paginator.num_pages)
            
            return render(request,
                          'blog/post/list.html',
                          {'posts': posts})



$ python manage.py runserver
попробовать ввести несуществующую страницу

Данное представление также должно обрабатывать случай, когда в пара-
метре page передается нечто отличное от целого числа.

        Пройдите по URL-адресу http://127.0.0.1:8000/blog/?page=asdf
        В этом случае при извлечении страницы asdf объект Paginator выдает ис-
        ключение PageNotAnInteger, поскольку номера страниц могут быть только
        целыми числами. 
        обработаем эту ошибку в представлении.

views.py
        from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger

        ...
        ...
        # обработка ошибки с несуществующей ошибкой
            try:
                posts = paginator.page(page_number)

            # Если page_number не целое число, то
            # выдать первую страницу
            except PageNotAnInteger:
                posts = paginator.page(1)
            
            # Если page_number находится вне диапазона, то
            # выдать последнюю страницу
            except EmptyPage:
                posts = paginator.page(paginator.num_pages)
            
            return render(request,
                          'blog/post/list.html',
                          {'posts': posts})

$ python manage.py runserver
пройдите по URL-адресу http://127.0.0.1:8000/blog/?page=asdf
первая страница результатов возвращается



РАЗРАБОТКА ПРЕДСТАВЛЕНИЙ НА ОСНОВЕ КЛАССОВ
Представления на основе классов по-
зволяют:
• организовывать исходный код, относящийся к HTTP-методам, таким
как GET, POST или PUT, в отдельные методы, не используя ветвление по
условию;
• использовать множественное наследование, чтобы создавать реисполь-
зуемые классы-представления (также именуемые примесями, примес-
ными классами или миксинами).


представления на основе класса для отображения списка постов
        
        создадим новое представление на основе класса, эквивалентное представ-
        лению post_list
        
        создадим класс, который будет наследовать от предла
        -гаемого веб-фреймворком Django типового представления ListView.

views.py
        from django.views.generic import ListView

        class PostListView(ListView):
            '''
            представление списка постов
            на основе класса
            '''  
            queryset = Post.published.all()   
            context_object_name = 'posts'
            paginate_by = 3
            template_name = 'blog/post/list.html'

urls.py
        urlpatterns = [
            # # все посты на странице
            # path('', views.post_list, name='post_list'),

            # все посты на странице на основе класса
            path('', views.PostListView.as_view(), name='post_list'),

            # # детальное представление поста по id
            # path('<int:id>/', views.post_detail, name='post_detail'),

            # исполью дату и слаг для URL-адреса 
            path('<int:year>/<int:month>/<int:day>/<slug:post>/',
                 views.post_detail,
                 name='post_detail'),
        ]

        чтобы постраничная разбивка продолжала работать, необходимо
        использовать правильный объект страницы, который передается в шаблон.
        Встроенное в Django типовое представление ListView передает запрошенную
        страницу в переменную с именем page_obj.

        необходимо соот-
        ветствующим образом отредактировать шаблон post/list.html, чтобы вста-
        вить разбивщика, используя правильную переменную


list.html




        Получается предыдущая конструкция не нужна, т.к. работала с функцией 
        <!-- блок с пагинацией -->
    {% include "pagination.html" with page=posts %}

        {% extends "blog/base.html" %}

        {% block title %}
            Киноблог Старинского
        {% endblock %}

        {% block content %}
            <h1>📽 Киноблог Старинского</h1>
            {% for post in posts %}
                <h2>    
                    <!-- Использование канонических URL -->
                    <a href="{{ post.get_absolute_url }}">
                        {{ post.title }}
                    </a>            
                </h2>

                <p class="date">
                    Опубликован: {{ post.publish }}, автор: {{ post.author }}
                </p>

                {{ post.body|truncatewords:30|linebreaks }}
            {% endfor %}
                
            <!-- Представление на основе класса -->
            {% include "pagination.html" with page=page_obj %}
        {% endblock %}

            

        <!-- 
            два шаблонных фильтра: 
            truncatewords усекает значение до указанного числа слов, а 
            linebreaks конвертирует результат в разрывы строк в формате HTML. 
        -->



$ python manage.py runserver
Поведение постранично разбитых ссылок должно быть таким же,как и в предыдущем
 представлении post_list.
Если попы-
таться загрузить страницу вне диапазона или передать нецелочисленное
значение в параметре page, то представление вернет HTTP-ответ с кодом
состояния, равным 404

        как это делать это глава 13 Бля!!!

        

РЕКОМЕНДАЦИЯ ПОСТОВ ПО ЭЛЕКТРОННОЙ ПОЧТЕ
   Я ПРОПУСКАЮ ЭТО!!
   

СОЗДАНИЕ СИСТЕМЫ КОММЕНТАРИЕВ
начнем с разработки модели для хранения комментариев пользо-
вателей к постам.

--- комментирование постов (Убрать маил)
models.py
        # комментирование постов (Убрать маил)
        class Comment(models.Model):
            post = models.ForeignKey(Post,
                                     on_delete=models.CASCADE,
                                     related_name='comments')
            name = models.CharField(max_length=80)
            email = models.EmailField()
            body = models.TextField()
            created = models.DateTimeField(auto_now_add=True)
            updated = models.DateTimeField(auto_now=True)
            active = models.BooleanField(default=True)

            class Meta:
                ordering = ['created']
                indexes = [
                    models.Index(fields=['created'])
                ]

            def __str__(self):
                return f"Comment by {self.name} on {self.post}"


$ python manage.py makemigrations blo
$ python manage.py migrate

Добавление комментариев на сайт администрирования

admin.py
        from .models import Post, Comment

        # комментарии
        @admin.register(Comment)
        class CommentAdmin(admin.ModelAdmin):
            list_display = ['name', 'email', 'post', 'created', 'active']
            list_filter = ['active', 'created', 'updated']
            search_fields = ['name', 'email', 'body']

$ python manage.py runserver


Создание форм из моделей
необходимо скомпоновать форму, позволяющую пользователям ком-
ментировать посты блога.
Django есть два базовых класса,
которые можно использовать для создания форм: Form (делиться по почте) и ModelForm (буду использовать сейчас)

создаю  mysite/blog/forms.py (в прошлом проекте он создавался, когда писвл делиться по почте)
forms.py
        from django import forms
        from .models import Comment


        # комментирование постов
        class CommentForm(forms.ModelForm):
            class Meta:
                # для какой модели использую форму
                model = Comment
                # какие поля использовать в форме (по умолчанию исп все)
                fields = ['name', 'email', 'body']


Оперирование формами ModelForm в представлениях
        добавим комментарную форму на страницу детальной информа-
        ции о посте и разработаем отдельное представление, которое посвящено
        передаче формы на обработку. Новое обрабатывающее форму представление
        позволит пользователю возвращаться к представлению детальной инфор-
        мации о посте, после того как комментарий будет сохранен в базе данных.

views.py
        from .models import Post, Comment
        from .forms import CommentForm
        from django.views.decorators.http import require_POST

        ...
        ...
        # комментирование постов
        @require_POST
        def post_comment(request, post_id):
            post = get_object_or_404(Post,
                                     id=post_id, 
                                     status=Post.Status.PUBLISHED)
            comment = None
            # Комментарий был отправлен
            form = CommentForm(data=request.POST)
            if form.is_valid():
                # Создать объект класса Comment, не сохраняя его в базе данных
                comment = form.save(commit=False)
                # Назначить пост комментарию
                comment.post = post
                # Сохранить комментарий в базе данных
                comment.save()
            
            return render(request, 'blog/post/comment.html',
                          {'post': post,
                           'form': form,
                           'comment': comment})

        Мы определили представление post_comment, которое принимает объект
        request и переменную post_id в качестве параметров. Мы будем использо-
        вать это представление, чтобы управлять передачей поста на обработку. Мы
        ожидаем, что форма будет передаваться с использованием HTTP-метода
        POST. Мы используем предоставляемый веб-фреймворком Django декоратор
        require_POST, чтобы разрешить запросы методом POST только для этого пред-
        ставления. Django позволяет ограничивать разрешенные для представлений
        HTTP-методы. Если пытаться обращаться к представлению посредством лю-
        бого другого HTTP-метода, то Django будет выдавать ошибку HTTP 405 (Метод
        не разрешен).
        
        В этом представлении реализованы следующие ниже действия.
        1. По id поста извлекается опубликованный пост, используя функцию со-
        кращенного доступа get_object_or_404().
        2. Определяется переменная comment с изначальным значением None. Ука-
        занная переменная будет использоваться для хранения комментарного
        объекта при его создании.
        3. Создается экземпляр формы, используя переданные на обработку POST-
        данные, и проводится их валидация методом is_valid(). Если форма
        невалидна, то шаблон прорисовывается с ошибками валидации.
        4. Если форма валидна, то создается новый объект Comment, вызывая ме-
        тод save() формы, и назначается переменной new_comment, как показано
        ниже:
                comment = form.save(commit=False)
        5. Метод save() создает экземпляр модели, к которой форма привязана,
        и сохраняет его в базе данных. Если вызывать его, используя commit=False,
        то экземпляр модели создается, но не сохраняется в базе данных. Такой
        подход позволяет видоизменять объект перед его окончательным со-
        хранением.
        
                Метод save() доступен для ModelForm, но не для экземпляров
                класса Form, поскольку они не привязаны ни к одной модели.
                
        6. Пост назначается созданному комментарию:
                comment.post = post
        7. Новый комментарий создается в базе данных путем вызова его метода
        save():
                comment.save()
        8. Прорисовывается шаблон blog/post/comment.html, передавая объекты
        post, form и comment в контекст шаблона. Этот шаблон еще не существует;
        мы создадим его позже.

urls.py
        urlpatterns = [
            # # все посты на странице
            # path('', views.post_list, name='post_list'),

            # все посты на странице на основе класса (нет обработки исключения)
            path('', views.PostListView.as_view(), name='post_list'),

            # # детальное представление поста по id
            # path('<int:id>/', views.post_detail, name='post_detail'),

            # исполью дату и слаг для URL-адреса 
            path('<int:year>/<int:month>/<int:day>/<slug:post>/',
                 views.post_detail,
                 name='post_detail'),

            # комментирование постов
             path('<int:post_id>/comment/',
                  views.post_comment, name='post_comment'),
        ]

Создание шаблонов комментарной формы
создадим шаблон комментарной формы, которая будет использоваться
в двух местах:
        • в шаблоне детальной информации о посте, ассоциированном с пред-
        ставлением post_detail, чтобы пользователи могли публиковать ком-
        ментарии;
        • в шаблоне комментария к посту, ассоциированном с представлением
        post_comment, чтобы отображать форму снова, если в форме есть какие-
        либо ошибки.
создадим шаблон формы и будем использовать шаблонный тег 
        {% include %}, 
        чтобы вставлять его в два других шаблона.
        
Внутри каталога templates/blog/post/ создайте новый каталог includes/ & comment_form.html

mysite/blog/templates/blog/post/includes/comment_form.html
        <h2> Добавить комментарий</h2>
        <form action="{% url "blog:post_comment" post.id %}" method="post">
            {{ form.as_p }}
            {% csrf_token %}
            <p><input type="submit" value="Опубликовать комментарий"></p>
        </form>


        мы динамически формируем URL-адрес action
        HTML-элемента <form>, используя шаблонный тег {% url %}.

        вставляем тег
        {% csrf_token %}, чтобы защититься от CSRF, поскольку данная форма будет
        передаваться на обработку методом POST



Внутри каталога templates/blog/post/ создайте новый файл приложения
blog и назовите его comment.html.



templates/blog/post/comment.html
        {% extends "blog/base.html" %}

        {% block title %}
            Добавление комментария
        {% endblock %}

        {% block content %}
            {% if comment %}
                <h2>Комментарий был добавлен.</h2>
                <p><a href="{{ post.get_absolute_url }}">Вернуться к посту</a></p>
            {% else %}
                {% include "blog/post/includes/comment_form.html" %}
            {% endif %}    
        {% endblock %}

        форма будет передаваться на обработку методом POST.
        Шаблон охватывает два разных сценария:
        • если переданные данные формы валидны, то переменная comment будет
        содержать созданный объект comment, и на страницу будет выведено со-
        общение об успехе;
        • если переданные данные формы невалидны, то переменной comment
        будет назначено значение None. В этом случае мы отобразим коммен-
        тарную форму. Для вставки созданного ранее шаблона comment_form.html
        используется шаблонный тег {% include %}.


Добавление комментариев в представление детальной информации о посте

views.py
        # Детальное представление поста. Исполью дату и слаг для URL-адреса 
        def post_detail(request, year, month, day, post):
            post = get_object_or_404(Post,
                                     status=Post.Status.PUBLISHED,
                                     slug=post,
                                     publish__year=year,
                                     publish__month=month,
                                     publish__day=day)
            
             # Список активных комментариев к этому посту
            comments = post.comments.filter(active=True)

            # Форма для комментирования пользователями
            form = CommentForm()

            return render(request,
                          'blog/post/detail.html',
                          {'post': post,
                           'comments': comments,
                           'form': form})


Добавление комментариев в шаблон детальной информации о посте
        • показывать общее число комментариев к посту;
        • показывать список комментариев;
        • показывать форму для добавления пользователями новых коммента-
        риев.

detail.html
        {% extends "blog/base.html" %}

        {% block title %}
            {{ post.title }}
        {% endblock %}

        {% block content %}
            <h1>{{ post.title }}</h1>

            <p class="date">
                Publidhed {{ post.publish }} by {{ post.author }}
            </p>
            {{ post.body|linebreaks }}  

             <!-- Общее число ком-ев к посту -->
            {% with comments.count as total_comments %}
                <h2>
                    {{ total_comments }} comment{{ total_comments|pluralize }}
                </h2>
            {% endwith %}
            
        {% endblock %}


        • используем Django ORM-преобразователь, при-
        меняя набор запросов comments.count(). Обратите внимание, что на языке
        шаблонов Django для вызова методов круглые скобки не используются. 
        • Тег {% with %}
         позволяет присваивать значение новой переменной, которая
         будет доступна в шаблоне до тех пор, 
         пока не появится тег {% endwith %}

        • pluralize, чтобы отображать суффикс
        множественного числа для слова comment, в зависимости от значения
        total_comments. 
        Шаблонные фильтры на входе принимают значение переменной,
        к которой они применяются, и на выходе возвращают вычисленное значе-
        ние. Подробнее о шаблонных фильтрах мы узнаем в главе 3 «Расширение
        приложения для ведения блога».
        Шаблонный фильтр pluralize возвращает строковый литерал с буквой «s»,
        если значение отличается от 1. Приведенный выше текст будет прорисовы-
        ваться как 0 comments, 1 comment или N comments, в зависимости от числа
        активных комментариев к посту.


        добавим список активных комментариев в шаблон деталь-
ной информации о посте.

detail.html
        {% extends "blog/base.html" %}

        {% block title %}
            {{ post.title }}
        {% endblock %}

        {% block content %}
            <h1>{{ post.title }}</h1>

            <p class="date">
                Опубликован: {{ post.publish }}, автор: {{ post.author }}
            </p>
            {{ post.body|linebreaks }}  

            <!-- Общее число ком-ев к посту -->
            {% with comments.count as total_comments %}
                <h2>
                    {{ total_comments }} comment{{ total_comments|pluralize }}
                    <hr>
                </h2>
            {% endwith %}

            <!-- список активных комментариев к посту -->
            {% for comment in comments %}
                <div class="comment">
                    <p class="info">
                        Комментарий {{ forloop.counter }}, 
                        автор: {{ comment.name }},
                        создан: {{ comment.created }}
                    </p>
                    {{ comment.body|linebreaks }}
                </div>
                {% empty %}
                    <p>Пока комментариев нет.</p>
            {% endfor %}            

        {% endblock %}




        
        
        *Комментарии прокручиваются в цикле посредством переменной 
        {{ forloop.counter }}, 
        которая обновляет счетчик цикла на каждой итерации. По каждо-
        му посту мы показываем имя пользователя, который его опубликовал, дату
        и текст комментария.


        добавим форму комментария в шаблон.

detail.html
        {% extends "blog/base.html" %}

        {% block title %}
            {{ post.title }}
        {% endblock %}

        {% block content %}
            <h1>{{ post.title }}</h1>

            <p class="date">
                Опубликован: {{ post.publish }}, автор: {{ post.author }}
            </p>
            {{ post.body|linebreaks }}  

            <!-- Общее число ком-ев к посту -->
            {% with comments.count as total_comments %}
                <h2>
                    {{ total_comments }} comment{{ total_comments|pluralize }}
                    <hr>
                </h2>
            {% endwith %}

            <!-- список активных комментариев к посту -->
            {% for comment in comments %}
                <div class="comment">
                    <p class="info">
                        Комментарий {{ forloop.counter }}, 
                        автор: {{ comment.name }},
                        создан: {{ comment.created }}
                    </p>
                    {{ comment.body|linebreaks }}
                </div>
                {% empty %}
                    <p>Пока комментариев нет.</p>
            {% endfor %}

            <!-- добавляю форму комментария -->
            {% include "blog/post/includes/comment_form.html" %}

        {% endblock %}


$ ./manage.py runserver


для README
Черновик для 📽 Киноблог Старинского
Закрепляю первые две главы Django 4

Приложение выводит (русифицировал):
-список постов(Заголовок, дата публикации, автор). Определенное количество постов
-Пагинация
-детальный вывод (Заголовок, Дата публикации, автор, кол-во комментариев, комментарии с номером, автором, датой создания)+форма для добавоения комментария
-в админке фильтры, поиск
-так же индексирование и сорртировка постов от свежих, slug











pgn 129
следующая глава
        *тегирование, 
        *рекомендация схожих постов, 
        *предоставление читателям новостной RSS-ленты
        *поиск постов.


               --- Планы, вопросы ---
-комментирование постов (Убрать маил)

-под постом есть форма комментария (Добавить комментарий), в ней Name, Body
нужно заменить на русский. Это только в модели?

-как сделать картинку на списке постов и три картинки в самом посте?

-как сделать, что бы на списке постов, указывалось количество комментариев?

-На сайте "3 comments":
detail.html:
         <!-- Общее число ком-ев к посту -->
            {% with comments.count as total_comments %}
                <h2>
                    {{ total_comments }} comment{{ total_comments|pluralize }}
                    <hr>
                </h2>
            {% endwith %}

        pluralize-добавляет 's' если множественное число, а в русском
        1-комментарий
        2(3, 4)-комментария
        5-комментриев  
        Как это сделать в русской версии?















https://github.com/PacktPublishing/Django-4-by-example/tree/main/Chapter02
